use crate::lexer::*;
use crate::ast::*;

grammar<'input>;

pub PROGRAM: Program<'input> = {
    STATEMENT => Program::Statement(<>),
    FUNCDEF+ => Program::FuncList(<>),
}

STATEMENT: Statement<'input> = {
    <VARDECL> ";",
    <READSTAT> ";",
    <RETURNSTAT> ";",
    IFSTAT,
    "{" <STATELIST> "}" => Statement::StatementList(<>),
}

VARDECL: Statement<'input> = {
    TYPE "ident" ("int_constant"?) => Statement::VariableDeclaration(<>),
}

// TODO: else
IFSTAT: Statement<'input> = {
    "if" "(" <c: EXPRESSION> ")" <a: STATEMENT> => {
        Statement::If {
            condition: c,
            true_path: Box::new(a),
            false_path: None,
        }
    }
}

READSTAT: Statement<'input> = "read" <LVALUE> => Statement::Read(<>);
RETURNSTAT: Statement<'input> = "return" => Statement::Return;

EXPRESSION: Expression<'input> = {
    NUMEXPRESSION,
    <a: NUMEXPRESSION> <op: CMPOP> <b: NUMEXPRESSION> => {
        Expression::Binary(Box::new(a), op, Box::new(b))
    },
}

CMPOP: BinOp = {
    "<" => BinOp::LessThan,
    ">" => BinOp::GreaterThan,
    "<=" => BinOp::LessThanEqual,
    ">=" => BinOp::GreaterThanEqual,
    "==" => BinOp::Equals,
    "!=" => BinOp::NotEquals,
}

NUMEXPRESSION: Expression<'input> = {
    TERM,
    <a: TERM> <op: NATOP> <b: TERM> => {
        Expression::Binary(Box::new(a), op, Box::new(b))
    },
};

TERM: Expression<'input> = {
    UNARYEXPR,
    <a: UNARYEXPR> <op: FLOATOP> <b: UNARYEXPR> => {
        Expression::Binary(Box::new(a), op, Box::new(b))
    },
}

UNARYEXPR: Expression<'input> = {
    FACTOR,
    <op: UNOP> <f: FACTOR> => {
        Expression::Unary(op, Box::new(f))
    },
}

FACTOR: Expression<'input> = {
    "int_constant" => Expression::IntLiteral(<>),
    "float_constant" => Expression::FloatLiteral(<>),
    "string_constant" => Expression::StringLiteral(<>),
    "null" => Expression::Null,
    LVALUE,
    "(" <NUMEXPRESSION> ")",
}

// TODO: TOTALLY WRONG
LVALUE: Expression<'input> = {
    "ident" => Expression::NameReference(<>),
}

NATOP: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
}

FLOATOP: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
}

UNOP: UnaryOp = {
    "-" => UnaryOp::Negative,
    "+" => UnaryOp::Positive,
}

TYPE: Type = {
    "int" => Type::Int,
    "float" => Type::Float,
    "string" => Type::String,
}

PARAMLIST: Vec<(Type, &'input str)> = Comma<PARAM>;
PARAM: (Type, &'input str) = TYPE "ident";

FUNCDEF: FunctionDefinition<'input> =
    "def" <name: "ident"> "(" <parameters: PARAMLIST> ")" "{" <body: STATELIST> "}" =>
        FunctionDefinition {<>};


STATELIST: Vec<Statement<'input>> = STATEMENT*;

// LALRPOP Macro
// http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

extern {
    type Location = usize;
    type Error = LexicalError<'input>;
    
    // all lexemes(terminals)
    enum TokenKind<'input> {
        "def" => TokenKind::FunctionKeyword,
        "ident" => TokenKind::Identifier(<&'input str>),
        "int_constant" => TokenKind::IntegerConstant(<i64>),
        "float_constant" => TokenKind::FloatConstant(<f64>),
        "string_constant" => TokenKind::StringConstant(<&'input str>),
        "null" => TokenKind::Null,
        "(" => TokenKind::OpenParenthesis,
        ")" => TokenKind::CloseParenthesis,
        "{" => TokenKind::OpenBraces,
        "}" => TokenKind::CloseBraces,
        "+" => TokenKind::Addition,
        "-" => TokenKind::Subtraction,
        "*" => TokenKind::Multiplication,
        "/" => TokenKind::Division,
        "%" => TokenKind::Mod,
        "," => TokenKind::Comma,
        ";" => TokenKind::SemiColon,
        "int" => TokenKind::IntType,
        "float" => TokenKind::FloatType,
        "string" => TokenKind::StringType,

        "if" => TokenKind::If,
        "else" => TokenKind::Else,
        "read" => TokenKind::Read,
        "print" => TokenKind::Print,
        "return" => TokenKind::Return,
        "for" => TokenKind::For,
        "break" => TokenKind::Break,
        "new" => TokenKind::New,

        "<" => TokenKind::LessThan,
        ">" => TokenKind::GreaterThan,
        "<=" => TokenKind::LessThanEqual,
        ">=" => TokenKind::GreaterThanEqual,
        "==" => TokenKind::Equals,
        "!=" => TokenKind::NotEquals,
    }
}
